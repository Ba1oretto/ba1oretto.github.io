---
title: day17 - API
tags:
  - Java学习笔记
---
  
<br/>
# 学习内容:
## 线程池, 锁, 单元测试方法, 反射, 注解, 设计模式<br/>

### 
```java

```

<br/><br/>
### 
```java

```

<br/><br/>
### 
```java

```

<br/><br/>
### 
```java

```

<br/><br/>
### 
```java

```

<br/><br/>
### 
```java

```

<br/><br/>
### 
```java

```

<br/><br/>
### 
```java

```

<br/><br/>
### 


```java

```


```java

```

<br/><br/>
# 复习<br/>

<br/><br/>
### TestThread
```java
/* 本类用于复写多线程实现方案1: 继承Thread*/
public class TestThread {
    public static void main(String[] args) {
        new MyThread().start();
        new MyThread().start();
        new MyThread().start();
        new MyThread().start();
    }
}


class MyThread extends Thread {
    static int m = 100;

    @Override
    public void run() {
        while (true) {
            synchronized (MyThread.class) {
                if (m > 0) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(getName() + " = " + m--);
                }
                if (m <= 0) break;
            }
        }
    }
}
```

### TestRunnable
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/* 本类用于复写多线程实现方案2: 实现Runnable*/
public class TestRunnable {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
//        new Thread(myRunnable).start();
//        new Thread(myRunnable).start();
//        new Thread(myRunnable).start();
//        new Thread(myRunnable).start();

        /* Executors是用来辅助创建线程池的工具
         * 常用方法: newFixedThreadPool(int x);这个方法可以创建指定数目现成的线程池对象
         * 创建出来的线程池对象就是ExecutorService, 负责: 创建/启动/销毁线程*/
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 5; i++) {
            /* execute()让线程池中的线程来执行业务, 每次调用对会将一个线程加入就绪队列*/
            executorService.execute(myRunnable); /* 本方法的参数就是你要执行的业务, 也就是目标业务类对象*/
        }
    }
}


class MyRunnable implements Runnable {
    int m = 100;

    @Override
    public void run() {
        while (true) {
            synchronized (MyRunnable.class) {
                if (m > 0) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + " = " + m--);
                }
                if (m <= 0) break;
            }
        }
    }
}
```

<br/><br/>
### TestRunnableV2
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/* 本类用于测试ReentrantReadWriteLock锁*/
public class TestRunnableV2 {
    public static void main(String[] args) {
        TestReentrantReadWriteLock testReentrantReadWriteLock = new TestReentrantReadWriteLock();
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 5; i++) {
            executorService.execute(testReentrantReadWriteLock);
        }
    }
}

class TestReentrantReadWriteLock implements Runnable {
    int m = 100;
    ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock(true);

    @Override
    public void run() {
        while (true) {
            reentrantReadWriteLock.writeLock().lock();
            try {
                if (m > 0) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + " = " + m--);
                }
                if (m <= 0) break;
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                reentrantReadWriteLock.writeLock().unlock();
            }
        }
    }
}
```